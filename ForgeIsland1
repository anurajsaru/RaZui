local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RaZui Hub",
    Folder = "MySuperHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 150,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,
})

Window:SetToggleKey(Enum.KeyCode.K)
Window:EditOpenButton({
    Title = "Open UI",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

--------------------------------------------------------------------------------
-- SERVICES & UTILS
--------------------------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local lp = Players.LocalPlayer

-- Configuration
local MOVEMENT_SPEED = 65 
local UNDER_OFFSET = Vector3.new(0, -7, 0) 

-- Noclip & Float Variables
local NoclipConnection = nil

-- 1. NOCLIP
local function SetNoclip(state)
    if state then
        if not NoclipConnection then
            NoclipConnection = RunService.Stepped:Connect(function()
                if lp.Character then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide == true then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoclipConnection then
            NoclipConnection:Disconnect()
            NoclipConnection = nil
        end
    end
end

-- 2. FLOAT
local function ToggleFloat(state)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = lp.Character.HumanoidRootPart
    local hum = lp.Character:FindFirstChild("Humanoid")

    if state then
        if hum then hum.PlatformStand = true end
        if not hrp:FindFirstChild("FarmFloat") then
            local bv = Instance.new("BodyVelocity")
            bv.Name = "FarmFloat"
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(100000, 100000, 100000)
            bv.Parent = hrp
        end
    else
        if hum then hum.PlatformStand = false end
        local bv = hrp:FindFirstChild("FarmFloat")
        if bv then bv:Destroy() end
    end
end

-- 3. TWEEN
local function TweenTo(targetCFrame)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = lp.Character.HumanoidRootPart
    
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local time = distance / MOVEMENT_SPEED
    
    if distance < 5 then
        hrp.CFrame = targetCFrame
        return
    end

    SetNoclip(true)
    ToggleFloat(true) 

    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    
    local completed = false
    local conn = tween.Completed:Connect(function() completed = true end)
    
    while not completed do
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled and not _G.TeleportToggleActive then
            tween:Cancel()
            ToggleFloat(false)
            break
        end
        task.wait()
    end
    
    if conn then conn:Disconnect() end
end

--------------------------------------------------------------------------------
-- FARM TAB
--------------------------------------------------------------------------------

local FarmTab = Window:Tab({Title = "Farm"})
FarmTab:Select()

local Section = FarmTab:Section({ 
    Title = "Farm Mobs",
})

_G.SelectedNPCs = { "Zombie" }

local function GetBaseName(displayName)
    if not displayName then return "" end
    return displayName:match("^(.-)%s*%(Level:") or displayName
end

local Dropdown = FarmTab:Dropdown({
    Title = "Select MOBs to Farm",
    Values = { "Zombie", "Delver Zombie", "Brute Zombie", "Slime" },
    Value = { "Zombie" },
    Multi = true,
    AllowNone = true,
    Callback = function(optionsTable) 
        _G.SelectedNPCs = optionsTable or {}
    end
})

local Toggle = FarmTab:Toggle({
    Title = "Auto Farm MOBs",
    Desc = "Targets Nearest MOB",
    Value = false,
    Callback = function(state)
        _G.AutoFarm = state
        
        if not state then
            SetNoclip(false)
            ToggleFloat(false)
            return
        end

        task.spawn(function()
            while _G.AutoFarm do
                if #_G.SelectedNPCs == 0 then
                    ToggleFloat(false)
                    task.wait(1)
                    continue
                end
                
                -- NEAREST FINDER LOGIC
                local target = nil
                local shortestDist = math.huge
                local myPos = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character.HumanoidRootPart.Position

                if myPos and workspace:FindFirstChild("Living") then
                    for _, v in pairs(workspace.Living:GetChildren()) do
                        if v:GetAttribute("IsNpc") == true and v:FindFirstChild("Humanoid") and v:FindFirstChild("HumanoidRootPart") then
                            local h = v.Humanoid
                            if h.Health > 0 then
                                local baseName = GetBaseName(h.DisplayName)
                                -- Check if selected
                                local match = false
                                for _, s in ipairs(_G.SelectedNPCs) do
                                    if s == baseName then match = true break end
                                end
                                
                                if match then
                                    local dist = (myPos - v.HumanoidRootPart.Position).Magnitude
                                    if dist < shortestDist then
                                        shortestDist = dist
                                        target = v
                                    end
                                end
                            end
                        end
                    end
                end

                if target then
                    local tRoot = target.HumanoidRootPart
                    local attackCFrame = tRoot.CFrame * CFrame.new(0, -7, 0) 
                    attackCFrame = CFrame.lookAt(attackCFrame.Position, tRoot.Position)

                    TweenTo(attackCFrame)
                    ToggleFloat(true) 
                    SetNoclip(true)

                    while _G.AutoFarm and target and target.Parent and target.Humanoid.Health > 0 do
                        if not lp.Character then break end
                        
                        -- Update Position constantly to stay close
                        local tPos = tRoot.Position
                        local goalPos = tRoot.CFrame * CFrame.new(0, -7, 0)
                        lp.Character.HumanoidRootPart.CFrame = CFrame.lookAt(goalPos.Position, tPos)
                        lp.Character.HumanoidRootPart.Velocity = Vector3.zero

                        -- Auto Equip
                        local char = lp.Character
                        if not char:FindFirstChildWhichIsA("Tool") then
                            local tool = lp.Backpack:FindFirstChild("Weapon") or lp.Backpack:FindFirstChildWhichIsA("Tool")
                            if tool then char.Humanoid:EquipTool(tool) end
                        end

                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer("Weapon")
                        end)
                        task.wait()
                    end
                else
                    ToggleFloat(false)
                    task.wait(0.5) -- Wait briefly before rescanning for nearest
                end
                task.wait()
            end
            ToggleFloat(false)
            SetNoclip(false)
        end)
    end
})

--------------------------------------------------------------------------------
-- ORE / CAVE FARMING
--------------------------------------------------------------------------------

local Section = FarmTab:Section({ Title = "Farm Caves" })

local ToolService = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")

local caves = {
    ["Start Cave"] = { folder = "Island1CaveStart", ores = {"Pebble"} },
    ["Middle Cave"] = { folder = "Island1CaveMid", ores = {"Rock"} },
    ["Deep Cave"] =  { folder = "Island1CaveDeep", ores = {"Rock", "Boulder"} },
    ["Roof"] =       { folder = "Roof", ores = {"Lucky Block"} }
}
local allOres = {"Pebble", "Rock", "Boulder", "Lucky Block"}

local function isRockValid(model, oreList)
    if not model or not model.Parent then return false end
    
    local nameMatch = false
    if oreList then
        for _, name in ipairs(oreList) do
            if model.Name == name or model:FindFirstChild(name) then nameMatch = true break end
        end
    else
        nameMatch = true
    end
    if not nameMatch then return false end

    local hPart = nil
    for _, c in ipairs(model:GetChildren()) do
        if c:GetAttribute("Health") then hPart = c break end
    end
    
    if hPart then
        local hp = hPart:GetAttribute("Health")
        return hp and hp > 0
    end
    return false
end

-- UPDATED: Now finds the NEAREST ore instead of random
local function FindNearestOre(mode)
    local rFolder = workspace:FindFirstChild("Rocks")
    if not rFolder then return nil end
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return nil end

    local myPos = lp.Character.HumanoidRootPart.Position
    local bestRock = nil
    local closestDist = math.huge

    if mode == "Cave" then
        local data = caves[_G.SelectedCave or "Start Cave"]
        local f = rFolder:FindFirstChild(data.folder)
        if f then
            -- Iterate ALL children to find nearest
            for _, v in ipairs(f:GetChildren()) do
                if isRockValid(v, data.ores) then 
                    local dist = (v:GetPivot().Position - myPos).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        bestRock = v
                    end
                end
            end
        end
    elseif mode == "Global" then
        local t = _G.SelectedGlobalOre or "Pebble"
        for _, folder in ipairs(rFolder:GetChildren()) do
            for _, v in ipairs(folder:GetChildren()) do
                if isRockValid(v, {t}) then 
                     local dist = (v:GetPivot().Position - myPos).Magnitude
                     if dist < closestDist then
                         closestDist = dist
                         bestRock = v
                     end
                end
            end
        end
    end
    return bestRock
end

local function MineLoop(flag, mode)
    while _G[flag] do
        local rock = FindNearestOre(mode) -- Uses Nearest Logic
        if rock then
            local rockPivot = rock:GetPivot()
            local minePos = rockPivot * CFrame.new(0, -7, 0)
            minePos = CFrame.lookAt(minePos.Position, rockPivot.Position)

            TweenTo(minePos)
            
            -- Stop Float, Enable Anchor (Stable)
            ToggleFloat(false)
            SetNoclip(true)
            
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.CFrame = minePos
                lp.Character.HumanoidRootPart.Anchored = true
            end

            while _G[flag] and rock and rock.Parent and isRockValid(rock) do
                if not lp.Character then break end
                
                local char = lp.Character
                if not char:FindFirstChild("Pickaxe") then
                   local p = lp.Backpack:FindFirstChild("Pickaxe")
                   if p then char.Humanoid:EquipTool(p) end
                end

                pcall(function() ToolService:InvokeServer("Pickaxe") end)
                task.wait(0.1)
            end
            
            -- Unanchor
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.Anchored = false
            end
        else
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.Anchored = false
            end
            task.wait(1)
        end
        task.wait()
    end
    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
        lp.Character.HumanoidRootPart.Anchored = false
    end
    SetNoclip(false)
end

FarmTab:Dropdown({
    Title = "Select Cave",
    Values = {"Start Cave", "Middle Cave", "Deep Cave", "Roof"},
    Value = "Start Cave",
    Callback = function(v) _G.SelectedCave = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Cave",
    Desc = " Targets Nearest Rock in Cave",
    Callback = function(state)
        _G.AutoCaveEnabled = state
        _G.AutoOreEnabled = false
        if not state and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
             lp.Character.HumanoidRootPart.Anchored = false
        end
        if state then task.spawn(function() MineLoop("AutoCaveEnabled", "Cave") end) end
    end
})

local Section = FarmTab:Section({ Title = "Farm Rocks" })

FarmTab:Dropdown({
    Title = "Select Rock Types",
    Values = allOres,
    Value = "Pebble",
    Callback = function(v) _G.SelectedGlobalOre = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Ore (Global)",
    Desc = "Targets Nearest Rock",
    Callback = function(state)
        _G.AutoOreEnabled = state
        _G.AutoCaveEnabled = false
        if not state and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
             lp.Character.HumanoidRootPart.Anchored = false
        end
        if state then task.spawn(function() MineLoop("AutoOreEnabled", "Global") end) end
    end
})

--------------------------------------------------------------------------------
-- SELL TAB
--------------------------------------------------------------------------------
local SellTab = Window:Tab({Title = "Sell Ores"})
local sellDelay = 5
local selectedItems = {}

SellTab:Button({
    Title = "Interact with Greedy Cey",
    Desc = "Press this to sell ores from anywhere. If the selected ores arenot selling press this again.",
    Callback = function()
        local args = { workspace:WaitForChild("Proximity"):WaitForChild("Greedy Cey") }
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Dialogue:InvokeServer(unpack(args))
    end
})

local items = {
    "Stone","Sand Stone","Copper","Iron","Tin","Silver","Gold",
    "Mushroomite","Platinum","Bananite","Cardboardite","Aite","Poopite"
}

SellTab:Section({ Title = "Auto Sell Island 1" })
SellTab:Dropdown({
    Title = "Select Items",
    Values = items,
    Value = {},
    Multi = true,
    Callback = function(v) selectedItems = v end
})

SellTab:Slider({
    Title = "Sell Delay",
    Value = {Min = 1, Max = 10, Default = 5},
    Callback = function(v) sellDelay = v end
})

SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell = state
        if state then
            task.spawn(function()
                while _G.AutoSell do
                    if #selectedItems > 0 then
                        for _, item in ipairs(selectedItems) do
                            if not _G.AutoSell then break end
                            pcall(function()
                                local basket = {[item] = 1}
                                game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = basket })
                            end)
                        end
                    end
                    task.wait(sellDelay)
                end
            end)
        end
    end
})

--------------------------------------------------------------------------------
-- POTION TAB
--------------------------------------------------------------------------------
local PotionTab = Window:Tab({Title = "Potion"})

local NameMap = {
    ["Health Potion 1"] = "HealthPotion1",
    ["Miner Potion 1"]  = "MinerPotion1",
    ["Speed Potion 1"]  = "MovementSpeedPotion1",
    ["Luck Potion 1"]   = "LuckPotion1",
    ["Damage Potion 1"] = "AttackDamagePotion1",
}
local potionList = {}
for _, v in pairs(NameMap) do table.insert(potionList, v) end
table.sort(potionList)
local selectedPotion = "HealthPotion1"
local buyAmount = 1

PotionTab:Section({ Title = "Purchase" })
PotionTab:Dropdown({ Title = "Select Potion", Values = potionList, Value = selectedPotion, Callback = function(v) selectedPotion = v end })
PotionTab:Slider({ Title = "Amount", Value = {Min = 1, Max = 10, Default = 1}, Callback = function(v) buyAmount = v end })
PotionTab:Button({
    Title = "Buy Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Purchase:InvokeServer(selectedPotion, buyAmount)
    end
})

local displayList = {}
for k, _ in pairs(NameMap) do table.insert(displayList, k) end
table.sort(displayList)
local selectedDisplay = "Health Potion 1"

PotionTab:Section({ Title = "Consume" })
PotionTab:Dropdown({ Title = "Select Potion", Values = displayList, Value = selectedDisplay, Callback = function(v) selectedDisplay = v end })
PotionTab:Button({
    Title = "Use Potion",
    Callback = function()
        local real = NameMap[selectedDisplay]
        if real then game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer(real) end
    end
})

--------------------------------------------------------------------------------
-- TELEPORT TAB
--------------------------------------------------------------------------------
local TeleportTab = Window:Tab({Title = "Teleport"})

local TeleportLocations = {
    ["Spawn"] = CFrame.new(-220, 37, 173),
    ["Enhancer"] = CFrame.new(-260, 20, 33),
    ["Rune Maker"] = CFrame.new(-270, 20, 138),
    ["Wizard"] = CFrame.new(-20, 81, -350),
}
local SelectedLocation = "Spawn"

local function DoTeleport()
    if TeleportLocations[SelectedLocation] then
        TweenTo(TeleportLocations[SelectedLocation])
        task.wait(0.5)
        ToggleFloat(false)
    end
end

TeleportTab:Dropdown({
    Title = "Location",
    Values = {"Spawn", "Enhancer", "Rune Maker", "Wizard"},
    Value = "Spawn",
    Callback = function(v) SelectedLocation = v if _G.TeleportToggleActive then DoTeleport() end end
})

TeleportTab:Toggle({
    Title = "Auto Teleport",
    Callback = function(state)
        _G.TeleportToggleActive = state
        if state then DoTeleport() end
    end
})

TeleportTab:Space()
TeleportTab:Button({
    Title = "Go to Forgotten Kingdom",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PortalService.RF.TeleportToIsland:InvokeServer("Forgotten Kingdom")
    end
})

--------------------------------------------------------------------------------
-- MSC
--------------------------------------------------------------------------------
local MSCTab = Window:Tab({Title = "MSC"})

local afkConn = nil
MSCTab:Toggle({
    Title = "Anti-AFK",
    Value = true,
    Callback = function(state)
        if state then
            afkConn = lp.Idled:Connect(function()
                game:GetService("VirtualUser"):Button2Down(Vector2.zero, workspace.CurrentCamera.CFrame)
                task.wait(0.2)
                game:GetService("VirtualUser"):Button2Up(Vector2.zero, workspace.CurrentCamera.CFrame)
            end)
        else
            if afkConn then afkConn:Disconnect() end
        end
    end
})
