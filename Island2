local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RaZui Hub",
    Folder = "MySuperHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 150,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,
})

Window:SetToggleKey(Enum.KeyCode.K)
Window:EditOpenButton({
    Title = "Open UI",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

--------------------------------------------------------------------------------
-- SERVICES & UTILS
--------------------------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local lp = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Debris = Workspace:WaitForChild("Debris")
local PlayerGui = lp:WaitForChild("PlayerGui")
local ForgeUI = PlayerGui:WaitForChild("Forge", 5) 

local MOVEMENT_SPEED = 65 
local NoclipConnection = nil

-- HELPER: Check if Alive
local function IsAlive()
    local char = lp.Character
    if not char then return false end
    local hum = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    return hum and root and hum.Health > 0
end

-- 1. NOCLIP
local function SetNoclip(state)
    if state then
        if not NoclipConnection then
            NoclipConnection = RunService.Stepped:Connect(function()
                if IsAlive() then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide == true then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoclipConnection then
            NoclipConnection:Disconnect()
            NoclipConnection = nil
        end
    end
end

-- 2. FLOAT
local function ToggleFloat(state)
    if not IsAlive() then return end
    local hrp = lp.Character.HumanoidRootPart
    local hum = lp.Character.Humanoid

    if state then
        hum.PlatformStand = true
        if not hrp:FindFirstChild("FarmFloat") then
            local bv = Instance.new("BodyVelocity")
            bv.Name = "FarmFloat"
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(100000, 100000, 100000)
            bv.Parent = hrp
        end
    else
        hum.PlatformStand = false
        local bv = hrp:FindFirstChild("FarmFloat")
        if bv then bv:Destroy() end
    end
end

-- 3. DEATH FREEZE
local function ConnectDeathMonitor(char)
    local hum = char:WaitForChild("Humanoid", 10)
    if hum then
        hum.Died:Connect(function()
            if char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Anchored = true
                char.HumanoidRootPart.Velocity = Vector3.zero
                local bv = char.HumanoidRootPart:FindFirstChild("FarmFloat")
                if bv then bv:Destroy() end
            end
        end)
    end
end

if lp.Character then ConnectDeathMonitor(lp.Character) end
lp.CharacterAdded:Connect(ConnectDeathMonitor)

-- 4. TWEEN MOVEMENT
local function TweenTo(targetCFrame)
    if not IsAlive() then return end

    local hrp = lp.Character.HumanoidRootPart
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local time = distance / MOVEMENT_SPEED
    
    if distance < 5 then
        hrp.CFrame = targetCFrame
        return
    end

    SetNoclip(true)
    ToggleFloat(true) 

    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    
    local completed = false
    local conn = tween.Completed:Connect(function() completed = true end)
    
    while not completed do
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled and not _G.TeleportToggleActive and not _G.ManualTeleport then
            tween:Cancel()
            ToggleFloat(false)
            break
        end
        
        -- STOP TWEEN IMMEDIATELY IF DEAD
        if not IsAlive() then
            tween:Cancel()
            ToggleFloat(false)
            break
        end

        task.wait()
    end
    
    if conn then conn:Disconnect() end
end

-- 5. AUTO CAMERA NOCLIP HELPER
local function SetCameraNoclip(state)
    if state then
        lp.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
    else
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled then
            lp.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Zoom
        end
    end
end

-- 6. SORTING HELPER
local function SelectFromList(list, priority)
    if #list == 0 then return nil end
    
    if priority == "Random" then
        return list[math.random(1, #list)].obj
    elseif priority == "Prioritize Highest MaxHealth" then
        table.sort(list, function(a, b) return a.maxHp > b.maxHp end)
        return list[1].obj
    elseif priority == "Prioritize Lowest MaxHealth" then
        table.sort(list, function(a, b) return a.maxHp < b.maxHp end)
        return list[1].obj
    else -- Default to Nearest
        table.sort(list, function(a, b) return a.dist < b.dist end)
        return list[1].obj
    end
end

--------------------------------------------------------------------------------
-- FARM TAB (NPCS)
--------------------------------------------------------------------------------
local FarmTab = Window:Tab({Title = "Farm"})
FarmTab:Select()

local Section = FarmTab:Section({ Title = "Farm Mobs" })

_G.SelectedNPCs = { "Skeleton Rogue" }
_G.MobPriority = "Nearest" -- Default

local function GetBaseName(displayName)
    if not displayName then return "" end
    return displayName:match("^(.-)%s*%(Level:") or displayName
end

FarmTab:Dropdown({
    Title = "Select MOBs to Farm",
    Values = {
        "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton", "Bomber",
        "Slime", "Blazing Slime", "Elite Rogue Skeleton", "Elite Deathaxe Skeleton", "Reaper"
    },
    Value = { "Skeleton Rogue" },
    Multi = true,
    AllowNone = true,
    Callback = function(optionsTable) 
        _G.SelectedNPCs = optionsTable or {}
    end
})

FarmTab:Dropdown({
    Title = "Target Priority",
    Values = { "Nearest", "Random", "Prioritize Highest MaxHealth", "Prioritize Lowest MaxHealth" },
    Value = "Nearest",
    Callback = function(v) 
        _G.MobPriority = v 
    end
})

FarmTab:Toggle({
    Title = "Auto Farm MOBs",
    Desc = "Targets Selected MOBs",
    Value = false,
    Callback = function(state)
        _G.AutoFarm = state
        SetCameraNoclip(state)
        
        if not state then
            -- SAFETY TELEPORT (14 STUDS)
            if IsAlive() then
                local hrp = lp.Character.HumanoidRootPart
                hrp.CFrame = hrp.CFrame + Vector3.new(0, 14, 0)
                hrp.Velocity = Vector3.zero
            end
            SetNoclip(false)
            ToggleFloat(false)
            return
        end

        task.spawn(function()
            while _G.AutoFarm do
                -- STRICT DEATH CHECK
                if not IsAlive() then
                    repeat task.wait(0.5) until IsAlive()
                    task.wait(2) -- Wait for character to load
                end

                if #_G.SelectedNPCs == 0 then
                    ToggleFloat(false)
                    task.wait(1)
                    continue
                end
                
                local validTargets = {}
                local myPos = lp.Character.HumanoidRootPart.Position

                if workspace:FindFirstChild("Living") then
                    for _, v in pairs(workspace.Living:GetChildren()) do
                        if v:GetAttribute("IsNpc") == true and v:FindFirstChild("Humanoid") and v:FindFirstChild("HumanoidRootPart") then
                            local h = v.Humanoid
                            if h.Health > 0 then
                                local baseName = GetBaseName(h.DisplayName)
                                local match = false
                                for _, s in ipairs(_G.SelectedNPCs) do
                                    if s == baseName then match = true break end
                                end
                                
                                if match then
                                    local dist = (myPos - v.HumanoidRootPart.Position).Magnitude
                                    table.insert(validTargets, {
                                        obj = v,
                                        dist = dist,
                                        maxHp = h.MaxHealth or 100
                                    })
                                end
                            end
                        end
                    end
                end

                local target = SelectFromList(validTargets, _G.MobPriority)

                if target then
                    local tRoot = target.HumanoidRootPart
                    local attackCFrame = tRoot.CFrame * CFrame.new(0, -7, 0) 
                    attackCFrame = CFrame.lookAt(attackCFrame.Position, tRoot.Position)

                    TweenTo(attackCFrame)
                    
                    -- IF DIED DURING TWEEN, RESTART LOOP
                    if not IsAlive() then continue end

                    ToggleFloat(true) 
                    SetNoclip(true)

                    while _G.AutoFarm and target and target.Parent and target.Humanoid.Health > 0 do
                        if not IsAlive() then break end
                        
                        if lp.Character:FindFirstChild("HumanoidRootPart") and target:FindFirstChild("HumanoidRootPart") then
                            local tPos = target.HumanoidRootPart.Position
                            local goalPos = target.HumanoidRootPart.CFrame * CFrame.new(0, -7, 0)
                            lp.Character.HumanoidRootPart.CFrame = CFrame.lookAt(goalPos.Position, tPos)
                            lp.Character.HumanoidRootPart.Velocity = Vector3.zero
                        end

                        local myChar = lp.Character
                        if myChar and not myChar:FindFirstChildWhichIsA("Tool") then
                            local tool = lp.Backpack:FindFirstChild("Weapon") or lp.Backpack:FindFirstChildWhichIsA("Tool")
                            if tool and myChar:FindFirstChild("Humanoid") then myChar.Humanoid:EquipTool(tool) end
                        end

                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer("Weapon")
                        end)
                        task.wait()
                    end
                else
                    ToggleFloat(false)
                    task.wait(0.5)
                end
                task.wait()
            end
            ToggleFloat(false)
            SetNoclip(false)
            SetCameraNoclip(false)
        end)
    end
})

--------------------------------------------------------------------------------
-- ORE / CAVE FARMING
--------------------------------------------------------------------------------

local Section = FarmTab:Section({ Title = "Mining (Caves & Ores)" })
local ToolService = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")

-- Shared Mining Priority
_G.MiningPriority = "Nearest" 

FarmTab:Dropdown({
    Title = "Mining Target Priority",
    Values = { "Nearest", "Random", "Prioritize Highest MaxHealth", "Prioritize Lowest MaxHealth" },
    Value = "Nearest",
    Callback = function(v) _G.MiningPriority = v end
})

local caves = {
    ["Start Cave"] = { folders = {"Island2CaveStart"}, ores = {"Basalt Rock"} },
    ["Middle Cave"] = { folders = {"Island2CaveMid"}, ores = {"Basalt Rock"} },
    ["Danger Cave"] = { folders = {"Island2CaveDanger1", "Island2CaveDanger2", "Island2CaveDanger3", "Island2CaveDanger4", "Island2CaveDangerClosed"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein"} },
    ["Deep Cave"] = { folders = {"Island2CaveDeep"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein"} },
    ["Goblin Cave"] = { folders = {"Island2GoblinCave"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Earth Crystal", "Crimson Crystal", "Cyan Crystal", "Light Crystal", "Voilet Crystal" } },
    ["Volcanic Depths"] = { folders = {"Island2VolcanicDepths", "Island2CaveLavaClosed"}, ores = {"Basalt Core", "Basalt Vein", "Volcanic Rock"} }
}

local allOres = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Volcanic Rock", "Earth Crystal", "Crimson Crystal", "Cyan Crystal", "Light Crystal", "Voilet Crystal"}

local RockBlacklist = {} -- [Instance] = tick()

-- NEW FUNCTION: Check if other players are near the rock
local function IsRockOccupied(rock)
    local rockPos = rock:GetPivot().Position
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= lp and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (p.Character.HumanoidRootPart.Position - rockPos).Magnitude
            if dist < 18 then -- If player is within 18 studs, assume it's taken
                return true
            end
        end
    end
    return false
end

-- UPDATED isRockValid (Includes Occupied Check with Bypass)
local function isRockValid(model, oreList, checkFullHealth, ignoreOccupied)
    if not model or not model.Parent then return false, 0 end
    
    -- BLACKLIST CHECK
    if RockBlacklist[model] then
        if (tick() - RockBlacklist[model]) < 30 then 
            return false, 0 
        else
            RockBlacklist[model] = nil 
        end
    end
    
    -- CHECK OCCUPIED (Unless ignoreOccupied is true)
    if not ignoreOccupied and IsRockOccupied(model) then
        return false, 0
    end
    
    local nameMatch = false
    if oreList then
        for _, name in ipairs(oreList) do
            if model.Name == name or model:FindFirstChild(name) then nameMatch = true break end
        end
    else
        nameMatch = true
    end
    if not nameMatch then return false, 0 end

    local hPart = nil
    for _, c in ipairs(model:GetChildren()) do
        if c:GetAttribute("Health") then hPart = c break end
    end
    
    if hPart then
        local hp = hPart:GetAttribute("Health")
        local maxHp = hPart:GetAttribute("MaxHealth") or 100
        
        if not hp or hp <= 0 then return false, 0 end

        if checkFullHealth then
            if hp < maxHp then return false, 0 end
        end

        return true, maxHp
    end
    return false, 0
end

-- UPDATED FindBestOre (Uses Global Priority)
local function FindBestOre(mode)
    if not IsAlive() then return nil end
    local rFolder = workspace:FindFirstChild("Rocks")
    if not rFolder then return nil end

    local myPos = lp.Character.HumanoidRootPart.Position
    local candidates = {}

    if mode == "Cave" then
        local data = caves[_G.SelectedCave or "Start Cave"]
        if data and data.folders then
            for _, folderName in ipairs(data.folders) do
                local f = rFolder:FindFirstChild(folderName)
                if f then
                    for _, v in ipairs(f:GetChildren()) do
                        -- PASS FALSE to check occupied status during SEARCH
                        local valid, maxHp = isRockValid(v, data.ores, true, false)
                        if valid then 
                            table.insert(candidates, {
                                obj = v,
                                dist = (v:GetPivot().Position - myPos).Magnitude,
                                maxHp = maxHp
                            })
                        end
                    end
                end
            end
        end
    elseif mode == "Global" then
        local targetOres = _G.SelectedGlobalOres
        if not targetOres or #targetOres == 0 then targetOres = {"Basalt Rock"} end
        for _, folder in ipairs(rFolder:GetChildren()) do
            for _, v in ipairs(folder:GetChildren()) do
                -- PASS FALSE to check occupied status during SEARCH
                local valid, maxHp = isRockValid(v, targetOres, true, false)
                if valid then 
                    table.insert(candidates, {
                        obj = v,
                        dist = (v:GetPivot().Position - myPos).Magnitude,
                        maxHp = maxHp
                    })
                end
            end
        end
    end

    return SelectFromList(candidates, _G.MiningPriority)
end

local function MineLoop(flag, mode)
    while _G[flag] do
        -- STRICT DEATH CHECK: Wait if dead
        if not IsAlive() then
            SetNoclip(false)
            ToggleFloat(false)
            repeat task.wait(0.5) until IsAlive()
            task.wait(2) -- Extra buffer for loading
        end

        local rock = FindBestOre(mode)

        if rock then
            local rockPivot = rock:GetPivot()
            local minePos = rockPivot * CFrame.new(0, -7, 0)
            minePos = CFrame.lookAt(minePos.Position, rockPivot.Position)

            TweenTo(minePos)

            -- IF DIED DURING TWEEN, RESTART LOOP
            if not IsAlive() then 
                SetNoclip(false)
                ToggleFloat(false)
                continue 
            end
            
            ToggleFloat(false)
            SetNoclip(true)
            
            if IsAlive() then
                lp.Character.HumanoidRootPart.CFrame = minePos
                lp.Character.HumanoidRootPart.Anchored = true
            end

            local startMiningTime = tick()
            local BUGGED_TIMEOUT = 6 

            -- MINING LOOP
            while _G[flag] and rock and rock.Parent do
                -- PASS TRUE to IGNORE occupied status while MINING
                -- This ensures we finish the rock even if someone walks up to us
                local valid, _ = isRockValid(rock, nil, nil, true)
                if not valid then break end
                
                -- BREAK IF DEAD
                if not IsAlive() then break end
                
                local hPart = nil
                for _, c in ipairs(rock:GetChildren()) do
                    if c:GetAttribute("Health") then hPart = c break end
                end
                
                if hPart then
                    local curHp = hPart:GetAttribute("Health") or 100
                    local maxHp = hPart:GetAttribute("MaxHealth") or 100
                    
                    if (tick() - startMiningTime) > BUGGED_TIMEOUT then
                        if curHp >= maxHp then
                            RockBlacklist[rock] = tick()
                            break 
                        end
                    end
                end

                local char = lp.Character
                if not char:FindFirstChild("Pickaxe") then
                   local p = lp.Backpack:FindFirstChild("Pickaxe")
                   if p then char.Humanoid:EquipTool(p) end
                end

                pcall(function() ToolService:InvokeServer("Pickaxe") end)
                task.wait(0.1)
            end
            
            if IsAlive() then
                lp.Character.HumanoidRootPart.Anchored = false
            end
        else
            if IsAlive() then
                lp.Character.HumanoidRootPart.Anchored = false
            end
            task.wait(1)
        end
        task.wait()
    end
    
    if IsAlive() then
        lp.Character.HumanoidRootPart.Anchored = false
    end
    SetNoclip(false)
end

FarmTab:Dropdown({
    Title = "Select Cave",
    Values = { "Start Cave", "Middle Cave", "Danger Cave","Deep Cave", "Goblin Cave", "Volcanic Depths" },
    Value = "Start Cave",
    Callback = function(v) _G.SelectedCave = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Cave",
    Desc = "Targets Rocks in Cave",
    Callback = function(state)
        _G.AutoCaveEnabled = state
        _G.AutoOreEnabled = false
        SetCameraNoclip(state)
        
        if not state and IsAlive() then
             -- SAFETY TELEPORT (14 STUDS)
             local hrp = lp.Character.HumanoidRootPart
             hrp.CFrame = hrp.CFrame + Vector3.new(0, 14, 0)
             hrp.Velocity = Vector3.zero
             hrp.Anchored = false
             SetCameraNoclip(false)
             SetNoclip(false)
             ToggleFloat(false)
        end
        if state then task.spawn(function() MineLoop("AutoCaveEnabled", "Cave") end) end
    end
})

FarmTab:Space()

FarmTab:Dropdown({
    Title = "Select Rock Types",
    Values = allOres,
    Value = { "Basalt Rock" },
    Multi = true,
    AllowNone = true,
    Callback = function(v) _G.SelectedGlobalOres = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Ore",
    Desc = "Targets Rocks Anywhere",
    Callback = function(state)
        _G.AutoOreEnabled = state
        _G.AutoCaveEnabled = false
        SetCameraNoclip(state)
        
        if not state and IsAlive() then
             -- SAFETY TELEPORT (14 STUDS)
             local hrp = lp.Character.HumanoidRootPart
             hrp.CFrame = hrp.CFrame + Vector3.new(0, 14, 0)
             hrp.Velocity = Vector3.zero
             hrp.Anchored = false
             SetCameraNoclip(false)
             SetNoclip(false)
             ToggleFloat(false)
        end
        if state then task.spawn(function() MineLoop("AutoOreEnabled", "Global") end) end
    end
})

FarmTab:Toggle({
    Title = "Attack while farming rocks",
    Callback = function(state)
        _G.AttackWhileMining = state
        if state then
            task.spawn(function()
                while _G.AttackWhileMining do
                    pcall(function()
                        local args = { "Weapon" }
                        game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated"):InvokeServer(unpack(args))
                    end)
                    task.wait()
                end
            end)
        end
    end
})

--------------------------------------------------------------------------------
-- FORGE, SELL, ETC (UNIVERSAL FIX)
--------------------------------------------------------------------------------

local ForgeTab = Window:Tab({Title = "Forge"})
local AutoForgeEnabled = false
local ForgeConnections = {}

local function cleanupMouse()
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0) 
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end

-- Universal Click Offset Helper
local function getInsetY()
    if UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
        return 0 -- Mobile usually has no inset offset in VIM
    else
        return GuiService:GetGuiInset().Y -- PC needs this
    end
end

-- UPDATED: Click specific UI element center (Fixes mobile offset by checking absolute pos of the target ring)
local function clickVisualTarget(targetElement)
    if not targetElement or not targetElement.Parent then return end
    local absPos = targetElement.AbsolutePosition
    local absSize = targetElement.AbsoluteSize
    local centerX = absPos.X + (absSize.X / 2)
    local centerY = absPos.Y + (absSize.Y / 2) + getInsetY()
    
    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
    task.wait(0.05) 
    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
end

local function handleHammerNote(noteObject)
    local innerFrame = noteObject:WaitForChild("Frame", 5)
    if not innerFrame then return end
    local circle = innerFrame:WaitForChild("Circle", 5)
    local border = innerFrame:WaitForChild("Border", 5)
    if not circle or not border then return end

    local targetSize = border.Size.X.Scale 
    local con
    con = RunService.RenderStepped:Connect(function()
        if not AutoForgeEnabled then 
            if con then con:Disconnect() end 
            return 
        end
        if not noteObject or not noteObject.Parent or not circle or not circle.Parent then
            if con then con:Disconnect() end
            return
        end
        if circle.Size.X.Scale <= (targetSize + 0.02) then
            if con then con:Disconnect() end
            -- CLICK THE BORDER (Stationary Target) instead of noteObject
            clickVisualTarget(border)
        end
    end)
end

local isMelting = false
local function runMeltLoop()
    if isMelting then return end
    isMelting = true
    if not ForgeUI then ForgeUI = lp.PlayerGui:FindFirstChild("Forge") end
    if not ForgeUI or not ForgeUI:FindFirstChild("MeltMinigame") then 
        isMelting = false
        return 
    end
    local MeltMinigame = ForgeUI.MeltMinigame
    local Heater = MeltMinigame:WaitForChild("Heater")
    local Handle = Heater:WaitForChild("Top")
    local ProgressBar = MeltMinigame:WaitForChild("Bar")
    
    task.wait(0.3)
    
    -- Main Melt Loop
    while AutoForgeEnabled and MeltMinigame.Visible and ProgressBar.Area.AbsoluteSize.Y < (ProgressBar.Frame.AbsoluteSize.Y * 0.99) do
        local handlePos = Handle.AbsolutePosition
        local handleSize = Handle.AbsoluteSize
        
        -- 1. Calculate START position (Center of Handle)
        local startX = handlePos.X + (handleSize.X / 2)
        local startY = handlePos.Y + (handleSize.Y / 2) + getInsetY()
        
        -- 2. Calculate TARGET position (Original Y + 50% of Original Y)
        local targetRawY = handlePos.Y + (handlePos.Y * 0.50)
        local endY = targetRawY + (handleSize.Y / 2) + getInsetY()

        -- 3. Move to Start
        VirtualInputManager:SendMouseMoveEvent(startX, startY, game)
        task.wait(0.05) 

        -- 4. Click Down
        VirtualInputManager:SendMouseButtonEvent(startX, startY, 0, true, game, 1)
        task.wait(0.05) 
        
        -- 5. Drag Down (Interpolate)
        local steps = 0.01 
        for i = 0.01, steps do
            local lerpY = startY + ((endY - startY) * (i / steps))
            VirtualInputManager:SendMouseMoveEvent(startX, lerpY, game)
            RunService.RenderStepped:Wait()
        end
        
        task.wait(0.05) 

        -- 6. Drag Up (Interpolate Back to Start)
        for i = 0.01, steps do
            local lerpY = endY + ((startY - endY) * (i / steps)) -- Moves from End towards Start
            VirtualInputManager:SendMouseMoveEvent(startX, lerpY, game)
            RunService.RenderStepped:Wait()
        end

        task.wait(0.05)
        
        -- 7. Release Click at Start Position
        VirtualInputManager:SendMouseButtonEvent(startX, startY, 0, false, game, 1)
        
        -- 8. Wait for cooldown
        task.wait(0.1)
    end
    isMelting = false
end

local isPouring = false
local function runPourLoop()
    if isPouring then return end
    isPouring = true
    if not ForgeUI then ForgeUI = lp.PlayerGui:FindFirstChild("Forge") end
    if not ForgeUI or not ForgeUI:FindFirstChild("PourMinigame") then 
        isPouring = false
        return 
    end
    local PourMinigame = ForgeUI.PourMinigame
    local PourArea = PourMinigame.Frame.Area
    local PourLine = PourMinigame.Frame.Line
    while AutoForgeEnabled and isPouring and PourMinigame.Visible do
        local areaCenterY = PourArea.AbsolutePosition.Y + (PourArea.AbsoluteSize.Y / 2)
        local lineCenterY = PourLine.AbsolutePosition.Y + (PourLine.AbsoluteSize.Y / 2)
        if lineCenterY > areaCenterY then
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        else
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
        end
        RunService.RenderStepped:Wait()
    end
    cleanupMouse()
    isPouring = false
end

local function clickMoldUntilGone(moldModel)
    task.wait(0.2)
    while AutoForgeEnabled and moldModel and moldModel.Parent do
        local pivotCFrame = moldModel:GetPivot()
        local targetPosition = pivotCFrame.Position
        local vectorPos, onScreen = Camera:WorldToViewportPoint(targetPosition)
        if onScreen then
            VirtualInputManager:SendMouseButtonEvent(vectorPos.X, vectorPos.Y, 0, true, game, 1)
            task.wait(0.1) 
            VirtualInputManager:SendMouseButtonEvent(vectorPos.X, vectorPos.Y, 0, false, game, 1)
        end
        task.wait(0.1) 
    end
end

ForgeTab:Section({ Title = "Auto Forge" })
ForgeTab:Toggle({
    Title = "Auto Forge Master",
    Desc = "Auto Hammer, Melt, Pour & Mold",
    Value = false,
    Callback = function(state) 
        AutoForgeEnabled = state
        if not ForgeUI then ForgeUI = lp.PlayerGui:FindFirstChild("Forge") end
        if state and ForgeUI then
            if ForgeUI:FindFirstChild("HammerMinigame") then
                local hammerC = ForgeUI.HammerMinigame.ChildAdded:Connect(function(child)
                    if child.Name == "Frame" then handleHammerNote(child) end
                end)
                table.insert(ForgeConnections, hammerC)
            end
            if ForgeUI:FindFirstChild("MeltMinigame") then
                local meltC = ForgeUI.MeltMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
                    if ForgeUI.MeltMinigame.Visible then task.spawn(runMeltLoop) end
                end)
                table.insert(ForgeConnections, meltC)
            end
            if ForgeUI:FindFirstChild("PourMinigame") then
                local pourC = ForgeUI.PourMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
                    if ForgeUI.PourMinigame.Visible then
                        task.wait(0.5)
                        if ForgeUI.PourMinigame.Visible and AutoForgeEnabled then 
                            task.spawn(runPourLoop) 
                        end
                    else
                        isPouring = false
                    end
                end)
                table.insert(ForgeConnections, pourC)
            end
            local moldC = Debris.ChildAdded:Connect(function(child)
                if child.Name == "Mold" then clickMoldUntilGone(child) end
            end)
            table.insert(ForgeConnections, moldC)
            if ForgeUI:FindFirstChild("MeltMinigame") and ForgeUI.MeltMinigame.Visible then task.spawn(runMeltLoop) end
            if ForgeUI:FindFirstChild("PourMinigame") and ForgeUI.PourMinigame.Visible then 
                task.wait(0.5)
                if AutoForgeEnabled then task.spawn(runPourLoop) end
            end
            if Debris:FindFirstChild("Mold") then
                task.spawn(function() clickMoldUntilGone(Debris.Mold) end)
            end
        else
            for _, v in pairs(ForgeConnections) do v:Disconnect() end
            ForgeConnections = {}
            isMelting = false
            isPouring = false
            cleanupMouse()
        end
    end
})

local SellTab = Window:Tab({Title = "Sell Ores"})
local items = {"Iron","Gold","Silver","Cobalt","Titanium","Lapis Lazuli","Platinum","Boneite","Dark Boneite","Volcanic Rock","Quartz","Amethyst","Topaz","Diamond","Sapphire","Slimite","Cuprite","Obsidian","Emerald","Ruby","Rivalite","Uranium","Mythril","Eye Ore","Fireite","Magmaite","Lightite","Demonite","Darkryte"}
local items1 = {"Magenta Crystal","Crimson Crystal","Greem Crystal","Orange Crystal","Blue Crystal","Rainbow Crystal","Arcane Crystal"}

-- MODIFIED BUTTON: Teleport and interact (Fixed Tween Logic)
SellTab:Button({
    Title = "Teleport to Greedy Cey",
    Desc = "Teleports to Cey and interacts (Press E)",
    Callback = function()
        _G.ManualTeleport = true -- ALLOW TWEEN TO RUN
        local targetCFrame = CFrame.new(-144.024, 20.855, -27.657, -0.93, 0, -0.805, 0, 1, 0, 0.825, 0, -0.593)
        
        TweenTo(targetCFrame)
        
        _G.ManualTeleport = false -- RESET
        
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            lp.Character.HumanoidRootPart.Velocity = Vector3.zero
        end
        ToggleFloat(false)
        SetNoclip(false)
        
        task.wait(0.5)
        local promptPart = workspace.Proximity:FindFirstChild("Greedy Cey")
        if promptPart then
            local prompt = promptPart:FindFirstChildWhichIsA("ProximityPrompt")
            if prompt then
                if fireproximityprompt then
                    fireproximityprompt(prompt)
                else
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.E, false, game)
                    task.wait(0.1)
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.E, false, game)
                end
            end
        end
    end
})

local selectedItems = {}
local sellDelay = 5
SellTab:Section({ Title = "Auto Sell Island 2" })
SellTab:Dropdown({ Title = "Select Items", Values = items, Multi = true, Callback = function(v) selectedItems = v end })
SellTab:Slider({ Title = "Sell Delay", Value = {Min=1, Max=10, Default=5}, Callback = function(v) sellDelay = v end })
SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell1 = state
        if state then
            task.spawn(function()
                while _G.AutoSell1 do
                    for _, item in ipairs(selectedItems) do
                        if not _G.AutoSell1 then break end
                        pcall(function()
                             game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = {[item]=1} })
                        end)
                    end
                    task.wait(sellDelay)
                end
            end)
        end
    end
})

local selectedItems2 = {}
local sellDelay2 = 5
SellTab:Section({ Title = "Auto Sell Goblin Cave" })
SellTab:Dropdown({ Title = "Goblin Items", Values = items1, Multi = true, Callback = function(v) selectedItems2 = v end })
SellTab:Slider({ Title = "Sell Delay", Value = {Min=1, Max=10, Default=5}, Callback = function(v) sellDelay2 = v end })
SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell2 = state
        if state then
            task.spawn(function()
                while _G.AutoSell2 do
                    for _, item in ipairs(selectedItems2) do
                        if not _G.AutoSell2 then break end
                        pcall(function()
                             game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = {[item]=1} })
                        end)
                    end
                    task.wait(sellDelay2)
                end
            end)
        end
    end
})

local PotionTab = Window:Tab({Title = "Potion"})
local PotionMap = {
    ["Health Potion 2"]   = "HealthPotion2",
    ["Miner Potion 1"]    = "MinerPotion1",
    ["Speed Potion 1"]    = "MovementSpeedPotion1",
    ["Luck Potion 1"]     = "LuckPotion1",
    ["Damage Potion 1"]   = "AttackDamagePotion1"
}
local PotionList = {}
for n, _ in pairs(PotionMap) do table.insert(PotionList, n) end
table.sort(PotionList)

local buyName = "Health Potion 2"
local buyAmt = 1
PotionTab:Section({ Title = "Purchase" })
PotionTab:Dropdown({ Title = "Select Potion", Values = PotionList, Value = buyName, Callback = function(v) buyName = v end })
PotionTab:Slider({ Title = "Amount", Value = {Min=1,Max=10,Default=1}, Callback = function(v) buyAmt = v end })
PotionTab:Button({
    Title = "Buy Potion",
    Callback = function()
        local args = {
            PotionMap[buyName],
            buyAmt
        }
        local remote = game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ProximityService"):WaitForChild("RF"):WaitForChild("Purchase")
        remote:InvokeServer(unpack(args))
    end
})

local useName = "Health Potion 2"
PotionTab:Section({ Title = "Consume" })
PotionTab:Dropdown({ Title = "Select Potion", Values = PotionList, Value = useName, Callback = function(v) useName = v end })
PotionTab:Button({
    Title = "Use Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer(PotionMap[useName])
    end
})

local TeleportTab = Window:Tab({Title = "Teleport"})
local TeleportLocations = {
    ["Spawn"] = CFrame.new(-211, 21, -47),
    ["Enhancer"] = CFrame.new(13, 22, -127),
    ["Rune Maker"] = CFrame.new(-47, 22, -139),
    ["Wizard"] = CFrame.new(96, 48, 137),
    ["Captain Rowan"] = CFrame.new(26, 75, -67),
    ["Ruined Cave"] = CFrame.new(81, 75, -50),
    ["Volcanic Cave"] = CFrame.new(390, 66, 71),
    ["Goblin Cave"] = CFrame.new(80, 21, -245),
}
local SelectedLoc = "Spawn"

local function DoTp()
    if TeleportLocations[SelectedLoc] then
        TweenTo(TeleportLocations[SelectedLoc])
        task.wait(0.5)
        ToggleFloat(false)
    end
end

TeleportTab:Dropdown({
    Title = "Location",
    Values = {"Spawn", "Enhancer", "Rune Maker", "Wizard", "Captain Rowan", "Ruined Cave", "Goblin Cave", "Volcanic Cave"},
    Value = "Spawn",
    Callback = function(v) SelectedLoc = v if _G.TeleportToggleActive then DoTp() end end
})

TeleportTab:Toggle({
    Title = "Auto Teleport",
    Callback = function(state)
        _G.TeleportToggleActive = state
        if state then DoTp() end
    end
})

TeleportTab:Space()
TeleportTab:Button({
    Title = "Go to Stonewake's Cross",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PortalService.RF.TeleportToIsland:InvokeServer("Stonewake's Cross")
    end
})

if _G.TpConn then _G.TpConn:Disconnect() end
_G.TpConn = lp.CharacterAdded:Connect(function(c)
    if _G.TeleportToggleActive then
        c:WaitForChild("HumanoidRootPart", 10)
        task.wait(0.2)
        DoTp()
    end
end)

local MSCTab = Window:Tab({Title = "MSC"})

local afkConn = nil
local function setAntiAFK(state)
    if state then
        if afkConn then afkConn:Disconnect() end
        afkConn = lp.Idled:Connect(function()
            game:GetService("VirtualUser"):Button2Down(Vector2.zero, workspace.CurrentCamera.CFrame)
            task.wait(0.2)
            game:GetService("VirtualUser"):Button2Up(Vector2.zero, workspace.CurrentCamera.CFrame)
        end)
    else
        if afkConn then 
            afkConn:Disconnect() 
            afkConn = nil
        end
    end
end

setAntiAFK(true)

MSCTab:Toggle({
    Title = "Anti-AFK",
    Value = true,
    Callback = function(state)
        setAntiAFK(state)
    end
})
