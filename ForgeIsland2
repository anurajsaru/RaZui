local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RaZui Hub",
    Folder = "MySuperHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 150,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,
})

Window:SetToggleKey(Enum.KeyCode.K)
Window:EditOpenButton({
    Title = "Open UI",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

--------------------------------------------------------------------------------
-- SERVICES & UTILS (MOVEMENT SYSTEM)
--------------------------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local lp = Players.LocalPlayer

local MOVEMENT_SPEED = 65 
local NoclipConnection = nil

-- 1. NOCLIP
local function SetNoclip(state)
    if state then
        if not NoclipConnection then
            NoclipConnection = RunService.Stepped:Connect(function()
                if lp.Character then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide == true then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoclipConnection then
            NoclipConnection:Disconnect()
            NoclipConnection = nil
        end
    end
end

-- 2. FLOAT (For NPCs)
local function ToggleFloat(state)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = lp.Character.HumanoidRootPart
    local hum = lp.Character:FindFirstChild("Humanoid")

    if state then
        if hum then hum.PlatformStand = true end
        if not hrp:FindFirstChild("FarmFloat") then
            local bv = Instance.new("BodyVelocity")
            bv.Name = "FarmFloat"
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(100000, 100000, 100000)
            bv.Parent = hrp
        end
    else
        if hum then hum.PlatformStand = false end
        local bv = hrp:FindFirstChild("FarmFloat")
        if bv then bv:Destroy() end
    end
end

-- 3. TWEEN MOVEMENT
local function TweenTo(targetCFrame)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = lp.Character.HumanoidRootPart
    
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local time = distance / MOVEMENT_SPEED
    
    -- If very close, just snap
    if distance < 5 then
        hrp.CFrame = targetCFrame
        return
    end

    SetNoclip(true)
    ToggleFloat(true) 

    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    
    local completed = false
    local conn = tween.Completed:Connect(function() completed = true end)
    
    while not completed do
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled and not _G.TeleportToggleActive then
            tween:Cancel()
            ToggleFloat(false)
            break
        end
        task.wait()
    end
    
    if conn then conn:Disconnect() end
end

--------------------------------------------------------------------------------
-- FARM TAB (NPCS)
--------------------------------------------------------------------------------
local FarmTab = Window:Tab({Title = "Farm"})
FarmTab:Select()

local Section = FarmTab:Section({ Title = "Farm Mobs" })

_G.SelectedNPCs = { "Skeleton Rogue" }

local function GetBaseName(displayName)
    if not displayName then return "" end
    return displayName:match("^(.-)%s*%(Level:") or displayName
end

FarmTab:Dropdown({
    Title = "Select MOBs to Farm",
    Values = {
        "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton", "Bomber",
        "Slime", "Blazing Slime", "Elite Rogue Skeleton", "Elite Deathaxe Skeleton", "Reaper"
    },
    Value = { "Skeleton Rogue" },
    Multi = true,
    AllowNone = true,
    Callback = function(optionsTable) 
        _G.SelectedNPCs = optionsTable or {}
    end
})

FarmTab:Toggle({
    Title = "Auto Farm MOBs",
    Desc = "Targets Nearest MOB",
    Value = false,
    Callback = function(state)
        _G.AutoFarm = state
        
        if not state then
            SetNoclip(false)
            ToggleFloat(false)
            return
        end

        task.spawn(function()
            while _G.AutoFarm do
                if #_G.SelectedNPCs == 0 then
                    ToggleFloat(false)
                    task.wait(1)
                    continue
                end
                
                -- FIND NEAREST NPC LOGIC
                local target = nil
                local shortestDist = math.huge
                local myPos = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character.HumanoidRootPart.Position

                if myPos and workspace:FindFirstChild("Living") then
                    for _, v in pairs(workspace.Living:GetChildren()) do
                        if v:GetAttribute("IsNpc") == true and v:FindFirstChild("Humanoid") and v:FindFirstChild("HumanoidRootPart") then
                            local h = v.Humanoid
                            if h.Health > 0 then
                                local baseName = GetBaseName(h.DisplayName)
                                -- Check validity against selection
                                local match = false
                                for _, s in ipairs(_G.SelectedNPCs) do
                                    if s == baseName then match = true break end
                                end
                                
                                if match then
                                    local dist = (myPos - v.HumanoidRootPart.Position).Magnitude
                                    if dist < shortestDist then
                                        shortestDist = dist
                                        target = v
                                    end
                                end
                            end
                        end
                    end
                end

                -- ATTACK LOGIC
                if target then
                    local tRoot = target.HumanoidRootPart
                    local attackCFrame = tRoot.CFrame * CFrame.new(0, -7, 0) 
                    attackCFrame = CFrame.lookAt(attackCFrame.Position, tRoot.Position)

                    TweenTo(attackCFrame)
                    ToggleFloat(true) 
                    SetNoclip(true)

                    while _G.AutoFarm and target and target.Parent and target.Humanoid.Health > 0 do
                        if not lp.Character then break end
                        
                        -- Keep position relative to enemy
                        local tPos = tRoot.Position
                        local goalPos = tRoot.CFrame * CFrame.new(0, -7, 0)
                        lp.Character.HumanoidRootPart.CFrame = CFrame.lookAt(goalPos.Position, tPos)
                        lp.Character.HumanoidRootPart.Velocity = Vector3.zero

                        -- Equip
                        local char = lp.Character
                        if not char:FindFirstChildWhichIsA("Tool") then
                            local tool = lp.Backpack:FindFirstChild("Weapon") or lp.Backpack:FindFirstChildWhichIsA("Tool")
                            if tool then char.Humanoid:EquipTool(tool) end
                        end

                        -- Swing
                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer("Weapon")
                        end)
                        task.wait()
                    end
                else
                    ToggleFloat(false)
                    task.wait(0.5)
                end
                task.wait()
            end
            ToggleFloat(false)
            SetNoclip(false)
        end)
    end
})

--------------------------------------------------------------------------------
-- ORE / CAVE FARMING (ANCHORED & NEAREST)
--------------------------------------------------------------------------------

local Section = FarmTab:Section({ Title = "Farm Caves" })
local ToolService = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")

-- CAVE DATA
local caves = {
    ["Start Cave"] = { folders = {"Island2CaveStart"}, ores = {"Basalt Rock"} },
    ["Middle Cave"] = { folders = {"Island2CaveMid"}, ores = {"Basalt Rock"} },
    ["Danger Cave"] = { folders = {"Island2CaveDanger1", "Island2CaveDanger2", "Island2CaveDanger3", "Island2CaveDanger4", "Island2CaveDangerClosed"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein"} },
    ["Deep Cave"] = { folders = {"Island2CaveDeep"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein"} },
    ["Goblin Cave"] = { folders = {"Island2GoblinCave"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Earth Crystal", "Crimson Crystal", "Cyan Crystal", "Light Crystal" } },
    ["Volcanic Depths"] = { folders = {"Island2VolcanicDepths", "Island2CaveLavaClosed"}, ores = {"Basalt Core", "Basalt Vein", "Volcanic Rock"} }
}

local allOres = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Volcanic Rock", "Earth Crystal", "Crimson Crystal", "Cyan Crystal", "Light Crystal"}

-- HELPER: Validate Rock
local function isRockValid(model, oreList)
    if not model or not model.Parent then return false end
    
    -- Name Check
    local nameMatch = false
    if oreList then
        for _, name in ipairs(oreList) do
            if model.Name == name or model:FindFirstChild(name) then nameMatch = true break end
        end
    else
        nameMatch = true
    end
    if not nameMatch then return false end

    -- Health Check
    local hPart = nil
    for _, c in ipairs(model:GetChildren()) do
        if c:GetAttribute("Health") then hPart = c break end
    end
    
    if hPart then
        local hp = hPart:GetAttribute("Health")
        return hp and hp > 0
    end
    return false
end

-- HELPER: Find Nearest Rock (Scans folders)
local function FindNearestOre(mode)
    local rFolder = workspace:FindFirstChild("Rocks")
    if not rFolder then return nil end
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return nil end

    local myPos = lp.Character.HumanoidRootPart.Position
    local bestRock = nil
    local closestDist = math.huge

    if mode == "Cave" then
        local data = caves[_G.SelectedCave or "Start Cave"]
        if data and data.folders then
            -- Scan ALL folders belonging to this cave definition
            for _, folderName in ipairs(data.folders) do
                local f = rFolder:FindFirstChild(folderName)
                if f then
                    for _, v in ipairs(f:GetChildren()) do
                        if isRockValid(v, data.ores) then 
                            local dist = (v:GetPivot().Position - myPos).Magnitude
                            if dist < closestDist then
                                closestDist = dist
                                bestRock = v
                            end
                        end
                    end
                end
            end
        end
    elseif mode == "Global" then
        local targetOres = _G.SelectedGlobalOres
        if not targetOres or #targetOres == 0 then targetOres = {"Basalt Rock"} end
        
        -- Scan entire Rocks folder
        for _, folder in ipairs(rFolder:GetChildren()) do
            for _, v in ipairs(folder:GetChildren()) do
                if isRockValid(v, targetOres) then 
                     local dist = (v:GetPivot().Position - myPos).Magnitude
                     if dist < closestDist then
                         closestDist = dist
                         bestRock = v
                     end
                end
            end
        end
    end
    return bestRock
end

-- MINING LOOP (Uses Anchor for Anti-Jitter)
local function MineLoop(flag, mode)
    while _G[flag] do
        local rock = FindNearestOre(mode)
        if rock then
            local rockPivot = rock:GetPivot()
            -- Position: Under rock, looking up
            local minePos = rockPivot * CFrame.new(0, -7, 0)
            minePos = CFrame.lookAt(minePos.Position, rockPivot.Position)

            TweenTo(minePos)
            
            -- SWITCH TO ANCHOR MODE
            ToggleFloat(false)
            SetNoclip(true)
            
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.CFrame = minePos
                lp.Character.HumanoidRootPart.Anchored = true
            end

            -- MINE UNTIL DEAD
            while _G[flag] and rock and rock.Parent and isRockValid(rock) do
                if not lp.Character then break end
                
                local char = lp.Character
                if not char:FindFirstChild("Pickaxe") then
                   local p = lp.Backpack:FindFirstChild("Pickaxe")
                   if p then char.Humanoid:EquipTool(p) end
                end

                pcall(function() ToolService:InvokeServer("Pickaxe") end)
                task.wait(0.1)
            end
            
            -- UNANCHOR
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.Anchored = false
            end
        else
            -- No rock found
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.Anchored = false
            end
            task.wait(1)
        end
        task.wait()
    end
    -- CLEANUP
    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
        lp.Character.HumanoidRootPart.Anchored = false
    end
    SetNoclip(false)
end

FarmTab:Dropdown({
    Title = "Select Cave",
    Values = { "Start Cave", "Middle Cave", "Danger Cave","Deep Cave", "Goblin Cave", "Volcanic Depths" },
    Value = "Start Cave",
    Callback = function(v) _G.SelectedCave = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Cave",
    Desc = "Targets Nearest Rocks in Cave",
    Callback = function(state)
        _G.AutoCaveEnabled = state
        _G.AutoOreEnabled = false
        if not state and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
             lp.Character.HumanoidRootPart.Anchored = false
        end
        if state then task.spawn(function() MineLoop("AutoCaveEnabled", "Cave") end) end
    end
})

-- GLOBAL ORES
local Section = FarmTab:Section({ Title = "Farm Rocks" })

FarmTab:Dropdown({
    Title = "Select Rock Types",
    Values = allOres,
    Value = { "Basalt Rock" },
    Multi = true,
    AllowNone = true,
    Callback = function(v) _G.SelectedGlobalOres = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Ore",
    Desc = "Targets Nearest Rocks",
    Callback = function(state)
        _G.AutoOreEnabled = state
        _G.AutoCaveEnabled = false
        if not state and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
             lp.Character.HumanoidRootPart.Anchored = false
        end
        if state then task.spawn(function() MineLoop("AutoOreEnabled", "Global") end) end
    end
})

--------------------------------------------------------------------------------
-- SELL TAB (PRESERVED)
--------------------------------------------------------------------------------
local SellTab = Window:Tab({Title = "Sell Ores"})

local items = {
    "Iron","Gold","Silver","Cobalt","Titanium","Lapis Lazuli","Platinum","Boneite","Dark Boneite","Volcanic Rock",
    "Quartz","Amethyst","Topaz","Diamond","Sapphire","Slimite","Curpite","Obsidian",
    "Emerald","Ruby","Rivalite","Uranium","Mythril","Eye Ore","Fireite",
    "Magmaite","Lightite","Demonite","Darkryte"
}

local items1 = {
    "Magenta Crystal","Crimson Crystal","Greem Crystal","Orange Crystal","Blue Crystal",
    "Rainbow Crystal","Arcane Crystal"
}

SellTab:Button({
    Title = "Interact with Greedy Cey",
    Desc = "Press this to sell ores from anywhere. If the selected ores arenot selling press this again.",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Dialogue:InvokeServer(workspace.Proximity["Greedy Cey"])
    end
})

-- AUTO SELL 1
local selectedItems = {}
local sellDelay = 5
SellTab:Section({ Title = "Auto Sell Island 2" })
SellTab:Dropdown({ Title = "Select Items", Values = items, Multi = true, Callback = function(v) selectedItems = v end })
SellTab:Slider({ Title = "Sell Delay", Value = {Min=1, Max=10, Default=5}, Callback = function(v) sellDelay = v end })
SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell1 = state
        if state then
            task.spawn(function()
                while _G.AutoSell1 do
                    for _, item in ipairs(selectedItems) do
                        if not _G.AutoSell1 then break end
                        pcall(function()
                             game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = {[item]=1} })
                        end)
                    end
                    task.wait(sellDelay)
                end
            end)
        end
    end
})

-- AUTO SELL 2 (Goblin)
local selectedItems2 = {}
local sellDelay2 = 5
SellTab:Section({ Title = "Auto Sell Goblin Cave" })
SellTab:Dropdown({ Title = "Goblin Items", Values = items1, Multi = true, Callback = function(v) selectedItems2 = v end })
SellTab:Slider({ Title = "Sell Delay", Value = {Min=1, Max=10, Default=5}, Callback = function(v) sellDelay2 = v end })
SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell2 = state
        if state then
            task.spawn(function()
                while _G.AutoSell2 do
                    for _, item in ipairs(selectedItems2) do
                        if not _G.AutoSell2 then break end
                        pcall(function()
                             game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = {[item]=1} })
                        end)
                    end
                    task.wait(sellDelay2)
                end
            end)
        end
    end
})

--------------------------------------------------------------------------------
-- POTION TAB
--------------------------------------------------------------------------------
local PotionTab = Window:Tab({Title = "Potion"})
local PotionMap = {
    ["Health Potion 2"]   = "HealthPotion2",
    ["Miner Potion 1"]    = "MinerPotion1",
    ["Speed Potion 1"]    = "MovementSpeedPotion1",
    ["Luck Potion 1"]     = "LuckPotion1",
    ["Damage Potion 1"]   = "AttackDamagePotion1"
}
local PotionList = {}
for n, _ in pairs(PotionMap) do table.insert(PotionList, n) end
table.sort(PotionList)

local buyName = "Health Potion 2"
local buyAmt = 1
PotionTab:Section({ Title = "Purchase" })
PotionTab:Dropdown({ Title = "Select Potion", Values = PotionList, Value = buyName, Callback = function(v) buyName = v end })
PotionTab:Slider({ Title = "Amount", Value = {Min=1,Max=10,Default=1}, Callback = function(v) buyAmt = v end })
PotionTab:Button({
    Title = "Buy Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Purchase:InvokeServer(PotionMap[buyName], buyAmt)
    end
})

local useName = "Health Potion 2"
PotionTab:Section({ Title = "Consume" })
PotionTab:Dropdown({ Title = "Select Potion", Values = PotionList, Value = useName, Callback = function(v) useName = v end })
PotionTab:Button({
    Title = "Use Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer(PotionMap[useName])
    end
})

--------------------------------------------------------------------------------
-- TELEPORT TAB
--------------------------------------------------------------------------------
local TeleportTab = Window:Tab({Title = "Teleport"})
local TeleportLocations = {
    ["Spawn"] = CFrame.new(-211, 21, -47),
    ["Enhancer"] = CFrame.new(13, 22, -127),
    ["Rune Maker"] = CFrame.new(-47, 22, -139),
    ["Wizard"] = CFrame.new(96, 48, 137),
    ["Captain Rowan"] = CFrame.new(26, 75, -67),
    ["Ruined Cave"] = CFrame.new(81, 75, -50),
    ["Volcanic Cave"] = CFrame.new(390, 66, 71),
    ["Goblin Cave"] = CFrame.new(80, 21, -245),
}
local SelectedLoc = "Spawn"

local function DoTp()
    if TeleportLocations[SelectedLoc] then
        -- Use our smooth tween for teleports too
        TweenTo(TeleportLocations[SelectedLoc])
        task.wait(0.5)
        ToggleFloat(false)
    end
end

TeleportTab:Dropdown({
    Title = "Location",
    Values = {"Spawn", "Enhancer", "Rune Maker", "Wizard", "Captain Rowan", "Ruined Cave", "Goblin Cave", "Volcanic Cave"},
    Value = "Spawn",
    Callback = function(v) SelectedLoc = v if _G.TeleportToggleActive then DoTp() end end
})

TeleportTab:Toggle({
    Title = "Auto Teleport",
    Callback = function(state)
        _G.TeleportToggleActive = state
        if state then DoTp() end
    end
})

TeleportTab:Space()
TeleportTab:Button({
    Title = "Go to Stonewake's Cross",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PortalService.RF.TeleportToIsland:InvokeServer("Stonewake's Cross")
    end
})

-- Fast Respawn Fix
if _G.TpConn then _G.TpConn:Disconnect() end
_G.TpConn = lp.CharacterAdded:Connect(function(c)
    if _G.TeleportToggleActive then
        c:WaitForChild("HumanoidRootPart", 10)
        task.wait(0.2)
        DoTp()
    end
end)

--------------------------------------------------------------------------------
-- MSC
--------------------------------------------------------------------------------
local MSCTab = Window:Tab({Title = "MSC"})

local afkConn = nil

local function setAntiAFK(state)
    if state then
        if afkConn then afkConn:Disconnect() end
        afkConn = lp.Idled:Connect(function()
            game:GetService("VirtualUser"):Button2Down(Vector2.zero, workspace.CurrentCamera.CFrame)
            task.wait(0.2)
            game:GetService("VirtualUser"):Button2Up(Vector2.zero, workspace.CurrentCamera.CFrame)
        end)
    else
        if afkConn then 
            afkConn:Disconnect() 
            afkConn = nil
        end
    end
end

-- Initialize Anti-AFK on script load
setAntiAFK(true)

MSCTab:Toggle({
    Title = "Anti-AFK",
    Value = true,
    Callback = function(state)
        setAntiAFK(state)
    end
})
